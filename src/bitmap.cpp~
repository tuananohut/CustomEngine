#include "headers/bitmap.h"

Bitmap::Bitmap()
{
  m_vertexBuffer = nullptr;
  m_indexBuffer = nullptr;
  m_Texture = nullptr;
}

Bitmap::Bitmap(const Bitmap& other) {}

Bitmap::~Bitmap() {}

bool Bitmap::Initialize(ID3D11Device* device,
			ID3D11DeviceContext* deviceContext,
			int screenWidth,
			int screenHeight,
			char* textureFilename,
			int renderX,
			int renderY)
{
  bool result;

  m_screenWidth = screenWidth;
  m_screenHeight = screenHeight;

  m_renderX = renderX;
  m_renderY = renderY;

  result = InitializeBuffers(device);
  if(!result)
    {
      return false;
    }

  result = LoadTexture(device, deviceContext, textureFilename);
  if(!result)
    {
      return false;
    }

  return true;
}

void Bitmap::Shutdown()
{
  ReleaseTexture();

  ShutdownBuffers();

  return; 
}

bool Bitmap::Render(ID3D11DeviceContext* deviceContext)
{
  bool result;

  result = UpdateBuffers(deviceContext);
  if(!result)
    {
      return false;
    }

  RenderBuffers(deviceContext);

  return true;
}

int Bitmap::GetIndexCount()
{
  return m_indexCount; 
}

ID3D11ShaderResourceView* Bitmap::GetTexture()
{
  return m_Texture->GetTexture(); 
}

bool Bitmap::InitializeBuffers(ID3D11Device* device)
{
  VertexType* vertices;
  unsigned long* indices;
  D3D11_BUFFER_DESC vertexBufferDesc, indexBufferDesc;
  D3D11_SUBRESOURCE_DATA vertexData, indexData;
  HRESULT result;
  int i;

  m_prevPosX = -1;
  m_prevPosY = -1;

  m_vertexCount = 6;

  m_indexCount = m_vertexCount;

  vertices = new VertexType[m_vertexCount];

  indices = new unsigned long[m_indexCount];

  memset(vertices, 0, (sizeof(VertexType)* m_vertexCount));

  for(i = 0; i < m_indexCount; i++)
    {
      indices[i] = i;
    }

  vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
  vertexBufferDesc.ByteWidth = sizeof(VertexType)* m_vertexCount;
  vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
  vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
  vertexBufferDesc.MiscFlags = 0;
  vertexBufferDesc.StructureByteStride = 0;

  vertexData.pSysMem = vertices;
  vertexData.SysMemPitch = 0;
  vertexData.SysMemSlicePitch = 0;

  result = device->CreateBuffer(&vertexBufferDesc, &vertexData, &m_vertexBuffer);
  if(FAILED)
    {
      return false;
    }

  indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
  indexBufferDesc.ByteWidth = sizeof(unsigned long)* m_indexCount;
  indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
  indexBufferDesc.CPUAccessFlags = 0;
  indexBufferDesc.MiscFlags = 0;
  indexBufferDesc.StructureByteStride = 0;

  indexData.pSysMem = indices;
  indexData.SysMemPitch = 0;
  indexData.SysMemSlicePitch = 0;

  result = device->CreateBuffer(&indexBufferDesc, &indexData, &m_indexBuffer);
  if(FAILED(result))
    {
      return false;
    }

  delete[] vertices;
  vertices = nullptr;

  delete[] indices;
  indices = nullptr;

  return true;
}

void Bitmap::ShutdownBuffers()
{
  if(m_indexBuffer)
    {
      m_indexBuffer->Release();
      m_indexBuffer = nullptr;
    }

  if(m_vertexBuffer)
    {
      m_vertexBuffer->Release();
      m_vertexBuffer = nullptr;
    }

  return; 
}

bool Bitmap::UpdateBuffers(ID3D11DeviceContext* deviceContent)
{
  float left, right, top, bottom;
  VertexType* vertices;
  D3D11_MAPPED_SUBRESOURCE mappedResource;
  VertexType* dataPtr;
  HRESULT result;

  if((m_prevPosX == m_renderX) && (m_prevPosY == m_renderY))
    {
      
    }
  
}
