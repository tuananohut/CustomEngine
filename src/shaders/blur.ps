cbuffer ScreenBuffer
{
	float screenWidth;
	float screenHeight; 
	float blurType;
	float padding;
};

Texture2D shaderTexture: register(t0);
SamplerState SampleType: register(s0);

struct PixelInputType
{
	float4 position: SV_POSITION;
	float2 tex: TEXCOORD0;
};

// Linear Sampling
float4 BlurPixelShader(PixelInputType input): SV_TARGET
{
	float texelSize = (blurType < 0.1f) ? 1.f / screenWidth : 1.f / screenHeight;
	float weight[5] = { 1.f, 0.7f, 0.5f, 0.15f, 0.1f };
	float normalization = (weight[0] + 2.f * (weight[1] + weight[2] + weight[3] + weight[4]));

	for (int i = 0; i < 5; i++)
	{
		weight[i] /= normalization;
	}

	float4 color = float4(0.f, 0.f, 0.f, 1.f);

	for (int i = 1; i <= 4; i++)
	{
		float2 offset = float2(texelSize * i, 0.f);
		/*added dual pass for aggressive blur*/
		color += shaderTexture.Sample(SampleType, input.tex + offset) * weight[i];
		// color += shaderTexture.Sample(SampleType, input.tex + offset) * weight[i]; 
		color += shaderTexture.Sample(SampleType, input.tex - offset) * weight[i];
		// color += shaderTexture.Sample(SampleType, input.tex - offset) * weight[i];
	}

	color += shaderTexture.Sample(SampleType, input.tex) * weight[0];

	color.a = 1.f;

	return color;
}

/*
//  Nearest neighbor sampling
float4 BlurPixelShader(PixelInputType input) : SV_TARGET
{
    float2 texCoord = input.tex;
    texCoord = floor(texCoord * float2(screenWidth, screenHeight)) / float2(screenWidth, screenHeight);
    return shaderTexture.Sample(SampleType, texCoord);
}
*/